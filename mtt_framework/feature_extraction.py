# -*- coding: utf-8 -*-
"""
feature_extraction

Created on Tue Feb 18 16:42:59 2025
@author: dpqb1
"""
import numpy as np
from scipy.ndimage import center_of_mass
from sklearn.decomposition import PCA
from abc import ABC, abstractmethod
import matplotlib.pyplot as plt

class FeatureExtractor(ABC):
    """
    Abstract base class for feature extractors.
    
    A feature extractor processes a detected spot and extracts relevant features.
    """

    def __init__(self, params=None):
        """
        Initialize the feature extractor.

        Parameters:
        - params (dict, optional): Configuration parameters for the feature extraction process.
        """
        self.params = params if params is not None else {}

    @abstractmethod
    def extract_features(self, detection):
        """
        Extract features from a detected spot.

        Parameters:
        - detection (object): The detected spot containing raw measurement data.

        Returns:
        - dict: A dictionary containing extracted feature values.
        """
        pass

class BasicFeatureExtractor(FeatureExtractor):
    def extract_features(self, detection):
        """
        Extract basic features: center of mass and intensity.

        Parameters:
        - detection (object): The detected spot containing raw measurement data.

        Returns:
        - dict: Extracted feature values.
        """
        bbox_features_dict = bbox_features(detection.mask) 
        # Extract bbox center and size
        bbox_center = bbox_features_dict['center'] if bbox_features_dict else None
        bbox_size = bbox_features_dict['size'] if bbox_features_dict else None
        com = compute_center_of_mass(detection.x_masked)
        principal_axes, variance = compute_principal_components(detection.x_masked,com)
        return {
            "Spot ID": detection.blob_label,
            "com": com,
            'bbox': find_bounding_box(detection.mask),
            "bbox_size": bbox_size,
            "bbox_center": bbox_center,
            "intensity": compute_intensity(detection.x_masked),
            "principal_axes": principal_axes,
            "variance": variance
            
        }

def compute_center_of_mass(x, labels=None, index=None):
    """
    Calculate the center of mass of the values of an array at labels.

    Parameters
    ----------
    input : ndarray
        Data from which to calculate center-of-mass. The masses can either
        be positive or negative.
    labels : ndarray, optional
        Labels for objects in `input`, as generated by `ndimage.label`.
        Only used with `index`. Dimensions must be the same as `input`.
    index : int or sequence of ints, optional
        Labels for which to calculate centers-of-mass. If not specified,
        the combined center of mass of all labels greater than zero
        will be calculated. Only used with `labels`.

    Returns
    -------
    center_of_mass : tuple, or list of tuples
        Coordinates of centers-of-mass.
    """
    return np.array(center_of_mass(x, labels=None, index=None))

def find_bounding_box(mask):
    """
    Finds the bounding box coordinates of non-zero pixels in a 3D binary mask.

    Parameters:
    -----------
        mask: A 3D numpy array representing the binary mask or masked data

    Returns:
    --------
        A tuple (tth_min, tth_max, eta_min, eta_max, ome_min, ome_max) 
        representing the bounding box coordinates, or None if no non-zero 
        pixels are found.
    """
    # Project along each axis to determine extents
    tth_any = np.any(mask, axis=(1, 2))  # Collapse eta and ome -> (tth,)
    eta_any = np.any(mask, axis=(0, 2))  # Collapse tth and ome -> (eta,)
    ome_any = np.any(mask, axis=(0, 1))  # Collapse tth and eta -> (ome,)

    # If mask is completely empty, return None
    if not np.any(tth_any) or not np.any(eta_any) or not np.any(ome_any):
        return None

    # Find min and max indices where mask is True
    tth_min, tth_max = np.where(tth_any)[0][[0, -1]]
    eta_min, eta_max = np.where(eta_any)[0][[0, -1]]
    ome_min, ome_max = np.where(ome_any)[0][[0, -1]]

    return np.array([tth_min, tth_max, eta_min, eta_max, ome_min, ome_max])

def find_bounding_box_2D(mask):
    """
    Finds the bounding box coordinates of non-zero pixels in a binary mask.

    Parameters:
    -----------
    mask: A 2D numpy array representing the binary mask or masked data.

    Returns:
    --------
    A tuple (tth_min, tth_max, eta_min, eta_max) representing 
    the bounding box coordinates or None if no non-zero pixels are found.
    """
    # Check for non-zero pixels along rows and columns
    rows = np.any(mask, axis=1)  # Check for non-zero pixels along rows
    cols = np.any(mask, axis=0)  # Check for non-zero pixels along columns

    if not np.any(rows) or not np.any(cols):
        return None  # Return None if no non-zero pixels are found

    # Get the min and max coordinates along each axis
    tth_min, tth_max = np.where(rows)[0][[0, -1]]
    eta_min, eta_max = np.where(cols)[0][[0, -1]]

    # Return the bounding box coordinates (tth_min, tth_max, eta_min, eta_max)
    return np.array([tth_min, tth_max, eta_min, eta_max])

def bbox_features(mask):
    """
    Computes features (center and size) from the bounding box of a detected spot.

    Parameters:
    -----------
    mask: A 3D numpy array representing the binary mask or masked data.

    Returns:
    --------
    A dictionary with the following features:
    - 'center': The center of the bounding box in each dimension (tta, eta, ome).
    - 'size': The size (extent) of the bounding box in each dimension (tta, eta, ome).
    """
    
    # Find the bounding box
    bbox = find_bounding_box(mask)
    if bbox is None:
        return {'center': None, 'size': None}
    
    tth_min, tth_max, eta_min, eta_max, ome_min, ome_max = bbox

    # Calculate the center of the bounding box in each dimension (tta, eta, ome)
    center_tth = (tth_min + tth_max) / 2
    center_eta = (eta_min + eta_max) / 2
    center_ome = (ome_min + ome_max) / 2
    center = [center_tth, center_eta, center_ome]

    # Calculate the size of the bounding box in each dimension
    size_tth = tth_max - tth_min + 1
    size_eta = eta_max - eta_min + 1
    size_omega = ome_max - ome_min + 1
    size = [size_tth, size_eta, size_omega]

    # Return the features as a dictionary
    return {
        'center': center,
        'size': size
    }

def compute_intensity(x):
    """
    Calculate total intensity of the spot

    Parameters
    ----------
    x input : ndarray
        Data from which to calculate total intensity. 

    Returns
    -------
    intensity : float
    The total intensity computed as the sum of all values in x.
    """
    
    intensity = np.sum(x)
    
    return intensity

def compute_velocity(prev_com, curr_com, dt=1):
    """
    compute the velocity og the com for a blob across two consecutive time step

    Parameters
    ----------
    prev_com : tuple or array
        The Center of mass at the previous time step
    curr_com : tuple or array
        The positio of the center of mass at the current timestep
    dt : float, optional
        The default is 1.

    Returns
    -------
    velocities : tuple 
        The velocity between two time step in each tth, eta, and 
        omega dimension.

    """
    #change in position
    if prev_com is None or curr_com is None:
        return np.zeros(3)
    com_change= np.array(curr_com) - np.array(prev_com)
    velocity= com_change / dt
    
    
    return velocity


def compute_acc(prev_velocity, curr_velocity, dt=1):
    """
    compute the acceleration of the com for a blob across two consecutive time step

    Parameters
    ----------
    prev_velocity : tuple or array
        The velocity at the previous time step.
    curr_velocity : tuple or array
        The velocity at the current time step.
    dt : float, optional
        The default is 1.

    Returns
    -------
    acceleration : tuple 
        The acceleration between two time step in each tth, eta, and 
        omega dimension.

    """
    if curr_velocity is None or prev_velocity is None:
        return np.zeros(3)
    
    acceleration= (np.array(curr_velocity) - np.array(prev_velocity))/dt
    
    return acceleration

#detect overlap by checking if two bounding boxes intersect
def check_overlap(bbox1, bbox2):
    return not (
        bbox1[1] < bbox2[0] or bbox2[1] < bbox1[0] or  # tta range
        bbox1[3] < bbox2[2] or bbox2[3] < bbox1[2] or  # eta range
        bbox1[5] < bbox2[4] or bbox2[5] < bbox1[4]    # ome range
    )


#is an integer that indicates the index of the overlapping spot
def overlap_index(bbox, all_bboxes):
    """
    Determines the index of the first overlapping spot, or -1 if no overlap is found.

    Parameters
    ----------
    bbox : tuple
        The bounding box of the current spot (tth_min, tth_max, eta_min, eta_max, ome_min, ome_max).
    all_bboxes : list of tuples
        List of bounding boxes for all previously detected spots.

    Returns
    -------
    int
        The index of the overlapping spot, or -1 if no overlap is found.
    """
    for idx, other_bbox in enumerate(all_bboxes):
        if check_overlap(bbox, other_bbox):
            # Return index of the first overlapping spot
            return idx  

    # No overlap found
    return -1  

def compute_principal_components(x, com):
    """
    Computes principal components of a 3D intensity distribution,
    weighting PCA by intensity values.

    Parameters:
    x   : np.ndarray (3D)  -> The intensity grid.
    com : np.ndarray (1D)  -> The center of mass, shape (3,).

    Returns:
    principal_axes  -> 3x3 matrix (rows are eigenvectors)
    variance        -> 3-element array (squared axis lengths)
    """
    # Get coordinates of all nonzero intensity values
    indices = np.argwhere(x > 0)
    intensities = x[indices[:, 0], indices[:, 1], indices[:, 2]]  # Extract intensity values

    # Compute intensity-weighted mean shift
    weighted_mean = np.average(indices, axis=0, weights=intensities)  # Weighted by intensity
    centered_data = indices - weighted_mean  # Center around intensity-weighted mean

    # Apply PCA with intensity weighting
    if centered_data.shape[0] > 4:
        pca = PCA(n_components=3)
        pca.fit(centered_data) 
        # Extract principal axes & variance
        principal_axes = pca.components_  # (3x3 matrix, each row = eigenvector)
        variance = pca.explained_variance_  # (3,) Eigenvalues = squared axis lengths
    else:
        principal_axes = None
        variance = None
        
    return principal_axes, variance


def visualize_pca_on_slices(x, com, principal_axes, variances):
    """
    Visualizes PCA principal axes projected onto 2D slices of a 3D intensity grid.
    
    Parameters:
    x               : np.ndarray (3D)  -> Intensity grid.
    com             : np.ndarray (1D)  -> Center of mass, shape (3,).
    principal_axes  : np.ndarray (3,3) -> PCA eigenvectors (each row is a principal axis).
    variances       : np.ndarray (3,)  -> Eigenvalues (squared axis lengths).
    """
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    # Compute axis lengths (sqrt of eigenvalues)
    axis_lengths = np.sqrt(variances) * 2  # Scale for visualization

    # Define colors for the PCA axes
    colors = ['r', 'g', 'b']  # PC1 = Red, PC2 = Green, PC3 = Blue

    # ✅ 1. XY Plane (Fix Z)
    z_idx = int(com[2])  # Middle slice in Z
    axes[0].imshow(x[:, :, z_idx].T, origin="lower", cmap="gray", aspect="auto")
    axes[0].set_title(f"XY Slice (Z = {z_idx})")

    for i in range(3):
        axes[0].arrow(com[0], com[1], 
                      axis_lengths[i] * principal_axes[i, 0], 
                      axis_lengths[i] * principal_axes[i, 1], 
                      color=colors[i], head_width=1)

    # ✅ 2. XZ Plane (Fix Y)
    y_idx = int(com[1])
    axes[1].imshow(x[:, y_idx, :].T, origin="lower", cmap="gray", aspect="auto")
    axes[1].set_title(f"XZ Slice (Y = {y_idx})")

    for i in range(3):
        axes[1].arrow(com[0], com[2], 
                      axis_lengths[i] * principal_axes[i, 0], 
                      axis_lengths[i] * principal_axes[i, 2], 
                      color=colors[i], head_width=1)

    # ✅ 3. YZ Plane (Fix X)
    x_idx = int(com[0])
    axes[2].imshow(x[x_idx, :, :].T, origin="lower", cmap="gray", aspect="auto")
    axes[2].set_title(f"YZ Slice (X = {x_idx})")

    for i in range(3):
        axes[2].arrow(com[1], com[2], 
                      axis_lengths[i] * principal_axes[i, 1], 
                      axis_lengths[i] * principal_axes[i, 2], 
                      color=colors[i], head_width=1)

    # ✅ Formatting
    for ax in axes:
        ax.set_xlabel("X" if ax == axes[0] else "Y")
        ax.set_ylabel("Y" if ax == axes[0] else "Z")
    
    plt.tight_layout()
    plt.show()


    
    
  
    